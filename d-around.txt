class Ferret {
  apiConfig(options={}){}
  model(modelName,Schema){
    //Adds models to the API
    //Retrieves a model
  }
}
Ferret.Schema = class {
  constructor(schema = {}){

  }
}
export default new Ferret();

//Setting up the API
ferret.apiConfig({
  base: "//localhost:3000/api"
})

//Setting up schemas
import ferret, { Schema } from "ferret";
const StorySchema = new Schema({
  title: String,
  body: String,
  userId: {
    type: String,
    required: [true, "A user is required"]
  }
});
ferret.model("Story", StorySchema);

//Creating new Stuff
import mongoose from "mongoose";
const Story = mongoose.model("Story");
const newStory = new Story({props})
newStory.save().then(story=>{}).catch(e=>{})


// Saving stuff
const connection = (C) => {
  return(class Connectorz extends Component {
    render(){
      return(<C {...this.props} bottoms="bottoms up!" />)
    }
  })
}

const Indispose = connection(class Indispose extends Component {
  render(){
    return(
      <div>{this.props.bottoms}</div>
    )
  }
})

<WrappedRappa title="Adams famiry" />


import flute, { fluteConnect } from "flute"

export default fluteConnect(({ Story })=>({ Story }))(class Index extends Component {
  render(){

  }
  handleSubmit(){
    const Story = flute.model("Story"),
          newStory = new Story({title, content});
    newStory.save().then(savedUser=>{
      const route = `/stories/${savedUser.id}`
      router.goTo(route)
    }).catch(({errors})=>{
      this.setState({errors})
    })
  }
})v


// @FLUTE_GET_STORY
// @FLUTE_GET_SUCCESS_STORY
// @FLUTE_PUT_STORY
// @FLUTE_PUT_SUCCESS_STORY
// @FLUTE_POST_STORY
// @FLUTE_POST_SUCCESS_STORY
// @FLUTE_DELETE_STORY
// @FLUTE_DELETE_SUCCESS_STORY
// @FLUTE_SET_STORY
// @FLUTE_REQUEST_INFO_STORY

const demoModel = {
  getting: false,
  posting: false,
  putting: false,
  deleting: false,
  // If the model is a singular type
  // The following fields are created
  version: null,
  requestVersion: null,
  requestStatus: null,
  requestBody: null,
  errors: {},
  record: {},
  // If the model is not a singleton, it gets a cache
  tmpCache: [
    {
      // Every change to the record should change the version
      // If the version is the same as the request version,
      // That means the state of the record is in the same state as
      // it was from the most recent request, meaning all the
      // Errors still apply.
      // The moment this TMP record is successfully requested,
      // It should move out of here, because the successful creation
      // Will move it to the index
      id: null, //<-- KEY
      version: null,
      requestVersion: null,
      requestStatus: null,
      requestBody: null,
      errors: {},
      creating: false,
      record:{}
    }
  ],
  cache: [
    {
      getting: false,
      posting: false,
      putting: false,
      deleting: false,
      version: null,
      requestVersion: null,
      requestStatus: null,
      requestBody: null,
      errors: {},
      record: {}
    }
  ],
}
//Uncaught (in promise) TypeError: Cannot assign to read only property 'record' of object '#<Story>'